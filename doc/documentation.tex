%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Dokumentacia k projektu 'Interpret pre jazyk IFJ 2013'
%%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt,a4paper,titlepage,final]{article}

% jazyk
\usepackage[slovak]{babel}
\usepackage[utf8]{inputenc}
% balicky prr odkazy
\usepackage[bookmarksopen,colorlinks,plainpages=false,urlcolor=blue,unicode]{hyperref}
\usepackage{url}
% obrazky
\usepackage[dvipdf]{graphicx}
% velikost stranky
\usepackage[top=3.5cm, left=2.5cm, text={17cm, 24cm}, ignorefoot]{geometry}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% titulní strana

\def\projname{Dokumentácia IFJ 2013}


\begin{titlepage}

% \vspace*{1cm}
\begin{figure}[!h]
  \centering
  \includegraphics[height=5cm]{doc/img/logo.eps}
\end{figure} 
\center Fakulta Informačních Technologií \\
\center Vysoké Učení Technické v Brně \\

\vfill

\begin{center}
\bigskip
\begin{Huge}
\projname\\
\end{Huge}
\begin{large}
Varianta a/4/II
\end{large}
\end{center}

\vfill

\begin{center}
\begin{Large}
\today
\end{Large}
\end{center}

\vfill

\begin{flushleft}
\begin{large}
Team leader: Marek Milkovič (xmilko01), 20\% \\
Členovia: Lukáš Vrabec (xvrabe07), 20\% \\
\hspace{57px} Ján Spišiak (xspisi03), 20\% \\
\hspace{57px} Ivan Ševčík (xsevci50), 20\% \\
\hspace{57px} Marek Bertovič (xberto00), 20\% \\ 
\end{large}
\end{flushleft}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% obsah
\pagestyle{plain}
\pagenumbering{roman}
\setcounter{page}{1}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% textova zprava
\newpage
\pagestyle{plain}
\pagenumbering{arabic}
\setcounter{page}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% sablona
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sablona} \label{uvod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\end{center}
SABLONA


%=============================================================================
\subsection{subsablona}
sablona
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% lex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Riešenie interpretu} \label{Riesenie interpretu}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\subsection{Lexikálna analýza}
Úlohy lexikálnej analýzy : \\
1. čítanie znakov zo vstupu a ich preklad na postupnosť tokenov, ktoré ďalej slúžia
syntaktickej analýze \\
2. odstránenie komentárov a bielych znakov v zdrojovom programe \\
3. nájdenie lexikálnych chýb v zdrojovom programe \\

Výstup lexikálnej analýzy je zároveň vstupom do syntaktickej analýzy, preto je
lexikálna analýza volaná syntaktickou analýzou. V našom prípade je konkrétne
výstup lexikálnej analýzy vektor tokenov, kde token je štruktúra obsahujúca
informácie o type tokenu ( typ tokenu je enumerácia všetkých prípustných tokenov )
a v prípade tokenov vyžadujúcich dalšie informácie ako napríklad obsah stringu
( znakový reťazec ) čí číselnu hodnotu tokenu typu číslo obsahuje štruktúra aj tieto dáta.
Úlohou je teda prejsť celým súborom až pokým scanner nenájde koniec vstupného súboru
( v C terminológii EOF - End Of File ), odhaliť prípadne lexikálne chyby a
v prípade lexikálnej bezchybnosti programu vyplniť vektor tokenmi a pripraviť
tak vstup do syntaktickej analýzy.

Implementácia lexikálnej analýzy spočíva v konštrukcii konečného automatu
( v angličtine finite state machine ), ktorý prečíta znak zo súboru, vyhodnotí
ho a na základe aktuálneho stavu a vstupného znaku môžu nastať tri nasledujúce
 možnosti:

1. aktuálny stav neumožnuje pokračovať s daným vstupným znakom a ukončuje tak
jeden token, znak sa "vracia" naspäť do vstupného súboru, avšak v našom prípade
len uloženie do pomocnej premennej a uchovanie informácie, že další znak pre
další token bude čítaný nie zo súboru ale z tejto pomocnej premennej.

2. aktálny stav umožnuje pokračovať s daným vstupným znakom, mení sa stav automatu,
avšak táto zmena môže byť v niektorých prípadoch nie úplne zmenou ak pokračujeme
do stavu, ktorý je zároveň aktuálnym stavom.

3. aktuálny stav neumožnuje pokračovat s daným vstupným znakom a zároveň
nedovoluje ukončiť token.To znamená,že sa v programe nachádza lexikálna chyba.

Špeciálnym prípadom sú stavy pre komentáre a blokové komentáre programu, ktoré
lexikálna analýza registruje, ale kedže sú nepodstatné pre činnosť zdrojového
programu, zahadzuje tieto informácie a ani ich ďalej nespracúva a neposiela
syntaktickej analýze v podobe tokenu.

Tento automat najlepšie ilustruje príloha č.1 , kde je nakreslený model
automatu lexikálnej analýzy.
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% sablona
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LL gramatika} \label{LL gramatika}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\subsection{LL gramatika}
PROG $\Rightarrow$ $\textless$?php BODY\\
BODY $\Rightarrow$ STMT BODY\\
BODY $\Rightarrow$ FUNC BODY\\
BODY $\Rightarrow$ \$\\
FUNC $\Rightarrow$ function id ( PARAM\_LIST ) \{ STMT\_LIST \}\\
STMT\_LIST $\Rightarrow$ $\varepsilon$\\
STMT\_LIST $\Rightarrow$ STMT STMT\_LIST\\
STMT $\Rightarrow$ var\_id = EXPR ;\\
STMT $\Rightarrow$ return EXPR ;\\
STMT $\Rightarrow$ break ;\\
STMT $\Rightarrow$ continue ;\\
STMT $\Rightarrow$ if ( EXPR ) \{ STMT\_LIST \} ELSEIF\_STMT ELSE\_STMT\\
STMT $\Rightarrow$ while ( EXPR ) \{ STMT\_LIST \}\\
STMT $\Rightarrow$ for ( FOR\_STMT\_1 ; FOR\_STMT\_2 ; FOR\_STMT\_1 ) \{ STMT\_LIST \}\\
ELSEIF\_STMT $\Rightarrow$ $\varepsilon$\\
ELSEIF\_STMT $\Rightarrow$ elseif ( EXPR ) \{ STMT\_LIST \} ELSEIF\_STMT\\
ELSE\_STMT $\Rightarrow$ $\varepsilon$\\
ELSE\_STMT $\Rightarrow$ else \{ STMT\_LIST \}\\
PARAM\_LIST $\Rightarrow$ $\varepsilon$\\
PARAM\_LIST $\Rightarrow$ var\_id DEF\_ARG NPARAM\_LIST\\
NPARAM\_LIST $\Rightarrow$ $\varepsilon$\\
NPARAM\_LIST $\Rightarrow$ , var\_id DEF\_ARG NPARAM\_LIST\\
DEF\_ARG $\Rightarrow$ $\varepsilon$\\
DEF\_ARG $\Rightarrow$ = literal\\
FOR\_STMT\_1 $\Rightarrow$ $\varepsilon$\\
FOR\_STMT\_1 $\Rightarrow$ var\_id = EXPR\\
FOR\_STMT\_2 $\Rightarrow$ $\varepsilon$\\
FOR\_STMT\_2 $\Rightarrow$ EXPR\\

%=============================================================================
\subsection{gramatika pre výrazy}

EXPR $\Rightarrow$ EXPR + EXPR \\
EXPR $\Rightarrow$ EXPR * EXPR \\
EXPR $\Rightarrow$ EXPR - EXPR \\
EXPR $\Rightarrow$ EXPR / EXPR \\
EXPR $\Rightarrow$ EXPR . EXPR \\
EXPR $\Rightarrow$ EXPR $\textless$ EXPR \\
EXPR $\Rightarrow$ EXPR $\textgreater$ EXPR \\
EXPR $\Rightarrow$ EXPR $\textgreater$= EXPR \\
EXPR $\Rightarrow$ EXPR $\textless$= EXPR \\
EXPR $\Rightarrow$ EXPR === EXPR \\
EXPR $\Rightarrow$ EXPR !== EXPR \\
EXPR $\Rightarrow$ EXPR \&\& EXPR \\
EXPR $\Rightarrow$ EXPR || EXPR \\
EXPR $\Rightarrow$ EXPR and EXPR \\
EXPR $\Rightarrow$ EXPR or EXPR \\
EXPR $\Rightarrow$ ! EXPR \\
EXPR $\Rightarrow$ ( EXPR ) \\
EXPR $\Rightarrow$ id ( ) \\
EXPR $\Rightarrow$ id ( EXPR )  \\
EXPR $\Rightarrow$ id ( EXPR , EXPR ) \\
EXPR $\Rightarrow$ id ( EXPR , EXPR , EXPR ) \\
EXPR $\Rightarrow$ var \\
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% IAL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algoritmy} \label{Algoritmy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\subsection{Merge sort}
Na implementáciu radiaceho algoritmu sme využili Merge sort. Ide o radenie
 typu rozdeľuj a panuj (angl. divide and conquer), v našej implementácií stabilný
 algoritmus s časovou zložitosťou O(N log(N)). Princíp alogritmu je jednoduchý.
 Pole sa rozdelí na menšie podpolia (v našom prípade veľkosti 1). Následne sa
 po pároch spoja, tak aby výsledné pole bolo tiež zoradené.

Naša implementácia je tzv. zhora-dolu (angl. top-down) s pomocným poľom o
 rovnakej veľkosti ako zdrojové pole. Tieto polia striedajú svoju funkciu, z
 jedného sa číta do druhého píše, čím sa odstráni potreba kopírovania
 medzivýsledku spať do zdrojového poľa. Toto sa ľahko uskutoční jednoduchou
 zámenou argumentou v rekurzívnom volaní funkcie. Celá logika našej funkcie
 stringCharSortDivide() spočíva teda v rozdelení zdrojového poľa rekurzívnym
 volaním (s vymenením zdrojovým a cieľovým poľom) na polovice v prípade že jeho
 veľkosť je vačšia než 2, a následným spojením týchto 2 polovíc, pri ktorom sa
 vždy vyberie prvok podľa váhy z danej polovice.

% mozno obrazok sem dat? odpoved: NIE uz bez obrazkov to bude dost velke :D 

%=============================================================================
\subsection{KMP substring search}
Knuth-Morris-Prattov algoritmus zrýchľuje vyhľadávanie podreťazca v reťazci, za
 využita informácie o výskyte podreťazcov v hľadanom reťazci ktoré sa
 zhodujú so prefixom hľadaného reťazca. Túto informáciu bude držat pomocná
 tabuľka, ktorú musíme pred hľadaním zostaviť.

Základný vyhľadávací algoritmus porovnáva podreťazec s reťazcom postupne po
 každom znaku. KMP sa vyhýba porovaniu toho istého znaku v prípade že bol
 porovnaný predošlými porovnaniami a nie je možné aby bol súčasťou podreťazca
 ktorý je prefixom hľadaného reťazca. Samotné vyhľadávanie má teda zložitosť
 len O(N).

Naša pomocná tabuľka bude držať indexy, od ktorých musíme znova začať porovnávať.
 Zostavíme ju jednoducho postupným porovnávaním podreťazcou hľadaného reťazca s
 jeho prefixom. V prípade že neexistuje podreťazec o veľkosti väčšej než 1
 shodujúci sa so prefixom, bude tabuľka plná núl.

Vyhľadávanie je jednoduché, v prípade neshody sa podľa tabuľky nastaví ktorým
 písmenom z podreťazca sa má pokračovať porovnávanie.

%=============================================================================
\subsection{Hash table}
Hash tabuľka je typ abstraktnej dátovej štruktúry, ktorý implementuje operácie
 nad prvkami identifikovanými unikátnymi kľúčmi. Vyznačuje sa najmä časovou
 zložitosťou O(1).

V našej implementácií používame hash funkciu djb2 (autor Bernstein). Ide o
 pomerne jednoduchú a rýchlu funkciu, pričom vypočítaný hash ukladáme spolu so
 záznamom v tabuľke pre zrychlénie rekalkulácie pozície záznamu v prípade
 zmeny veľkosti tabuľky. Pri vyhľadavaní v tabuľke sa vypočíta hash z klúča,
 urobí sa modulo podľa veľkosti tabuľky (zvyčajne mocnina 2 takže vcelku rýchla
 operácia), pristúpi sa na daný prvok poľa kde sa zistí index záznamu (a v
 prípade že nastala kolízia, iteruje sa cez odkaz na ďalší záznam), pričom vždy
 sa musia porovnať porovnať klúče.

Interne naša tabuľka používa vektor na ukladanie záznamov. Takáto implementácia
 šetrí pamäť a zrýchľuje zmenu veľkosti tabuľky no nevýhodou je väčšia záťaž na
 cache procesoru (taktiež operácia mazania záznamu by bola komplikovanejšia,
 pokiaľ by sme ju implementovali). Pri kolízií uložíme do predošlého záznamu
 odkaz na ďaľší záznam.

Zmena veľkosti tabuľky sa deje pri záťaži 0,75. Zahodí sa staré pole indexov a
 alokuje sa dvojnásobne väčšie. Následne sa postupne vkladajú všetky odkazy na
 záznamy z vektora do tabuľky, príp. sa vložia ako odkaz cez existujúci záznam.

% koniec dokumentace
\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
